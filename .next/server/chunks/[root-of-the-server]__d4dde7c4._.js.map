{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 82, "column": 0}, "map": {"version":3,"sources":["file:///home/sabid/dev/aura/models/User.ts"],"sourcesContent":["import mongoose, { Document, Schema } from 'mongoose';\n\n// TypeScript interface for User document\nexport interface IUser extends Document {\n  email: string;\n  username?: string;\n  password?: string;\n  googleId?: string;\n  name?: string;\n  avatar?: string;\n  isOnboardingComplete: boolean;\n  timezone: string;\n  isActive: boolean;\n  lastLoginAt?: Date;\n  acceptedTermsAt?: Date;\n  privacyPolicyAcceptedAt?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n  displayName: string; // virtual field\n}\n\n// User schema definition\nconst userSchema = new Schema<IUser>({\n  // Authentication fields\n  email: {\n    type: String,\n    required: true,\n    unique: true,\n    lowercase: true,\n    trim: true\n  },\n  username: {\n    type: String,\n    required: function(this: IUser) {\n      return !this.googleId; // Required only if not using OAuth\n    },\n    unique: true,\n    minlength: 3,\n    trim: true,\n    match: /^[a-zA-Z0-9_]+$/\n  },\n  password: {\n    type: String,\n    required: function(this: IUser) {\n      return !this.googleId; // Required only if not using OAuth\n    },\n    minlength: 8\n  },\n  \n  // OAuth fields\n  googleId: {\n    type: String,\n    unique: true,\n    sparse: true // Allows multiple null values\n  },\n  \n  // Profile information\n  name: {\n    type: String,\n    trim: true\n  },\n  avatar: {\n    type: String // URL to profile image\n  },\n  \n  // Onboarding status\n  isOnboardingComplete: {\n    type: Boolean,\n    default: false\n  },\n  \n  // User preferences\n  timezone: {\n    type: String,\n    default: 'UTC'\n  },\n  \n  // Account status\n  isActive: {\n    type: Boolean,\n    default: true\n  },\n  lastLoginAt: {\n    type: Date\n  },\n  \n  // Privacy and terms\n  acceptedTermsAt: {\n    type: Date\n  },\n  privacyPolicyAcceptedAt: {\n    type: Date\n  }\n}, {\n  timestamps: true, // Adds createdAt and updatedAt\n  toJSON: { \n    transform: function(doc: any, ret: any) {\n      delete ret.password;\n      delete ret.__v;\n      return ret;\n    }\n  }\n});\n\n// Indexes for performance\nuserSchema.index({ email: 1 });\nuserSchema.index({ googleId: 1 });\nuserSchema.index({ username: 1 });\nuserSchema.index({ createdAt: -1 });\n\n// Virtual for getting user's full display name\nuserSchema.virtual('displayName').get(function(this: IUser) {\n  return this.name || this.username || this.email.split('@')[0];\n});\n\n// Ensure virtual fields are included in JSON\nuserSchema.set('toJSON', { virtuals: true });\n\n// Export the model\nexport default mongoose.models.User || mongoose.model<IUser>('User', userSchema);\n"],"names":[],"mappings":";;;AAAA;;AAqBA,yBAAyB;AACzB,MAAM,aAAa,IAAI,yGAAA,CAAA,SAAM,CAAQ;IACnC,wBAAwB;IACxB,OAAO;QACL,MAAM;QACN,UAAU;QACV,QAAQ;QACR,WAAW;QACX,MAAM;IACR;IACA,UAAU;QACR,MAAM;QACN,UAAU;YACR,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,mCAAmC;QAC5D;QACA,QAAQ;QACR,WAAW;QACX,MAAM;QACN,OAAO;IACT;IACA,UAAU;QACR,MAAM;QACN,UAAU;YACR,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,mCAAmC;QAC5D;QACA,WAAW;IACb;IAEA,eAAe;IACf,UAAU;QACR,MAAM;QACN,QAAQ;QACR,QAAQ,KAAK,8BAA8B;IAC7C;IAEA,sBAAsB;IACtB,MAAM;QACJ,MAAM;QACN,MAAM;IACR;IACA,QAAQ;QACN,MAAM,OAAO,uBAAuB;IACtC;IAEA,oBAAoB;IACpB,sBAAsB;QACpB,MAAM;QACN,SAAS;IACX;IAEA,mBAAmB;IACnB,UAAU;QACR,MAAM;QACN,SAAS;IACX;IAEA,iBAAiB;IACjB,UAAU;QACR,MAAM;QACN,SAAS;IACX;IACA,aAAa;QACX,MAAM;IACR;IAEA,oBAAoB;IACpB,iBAAiB;QACf,MAAM;IACR;IACA,yBAAyB;QACvB,MAAM;IACR;AACF,GAAG;IACD,YAAY;IACZ,QAAQ;QACN,WAAW,SAAS,GAAQ,EAAE,GAAQ;YACpC,OAAO,IAAI,QAAQ;YACnB,OAAO,IAAI,GAAG;YACd,OAAO;QACT;IACF;AACF;AAEA,0BAA0B;AAC1B,WAAW,KAAK,CAAC;IAAE,OAAO;AAAE;AAC5B,WAAW,KAAK,CAAC;IAAE,UAAU;AAAE;AAC/B,WAAW,KAAK,CAAC;IAAE,UAAU;AAAE;AAC/B,WAAW,KAAK,CAAC;IAAE,WAAW,CAAC;AAAE;AAEjC,+CAA+C;AAC/C,WAAW,OAAO,CAAC,eAAe,GAAG,CAAC;IACpC,OAAO,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;AAC/D;AAEA,6CAA6C;AAC7C,WAAW,GAAG,CAAC,UAAU;IAAE,UAAU;AAAK;uCAG3B,yGAAA,CAAA,UAAQ,CAAC,MAAM,CAAC,IAAI,IAAI,yGAAA,CAAA,UAAQ,CAAC,KAAK,CAAQ,QAAQ","debugId":null}},
    {"offset": {"line": 189, "column": 0}, "map": {"version":3,"sources":["file:///home/sabid/dev/aura/models/Metric.ts"],"sourcesContent":["import mongoose, { Document, Schema, Types } from 'mongoose';\n\n// TypeScript interface for Metric document\nexport interface IMetric extends Document {\n  userId: Types.ObjectId;\n  name: string;\n  description?: string;\n  minValue: number;\n  maxValue: number;\n  scaleLabels: Map<string, string>;\n  color: string;\n  sortOrder: number;\n  isActive: boolean;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Metric schema definition\nconst metricSchema = new Schema<IMetric>({\n  userId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true\n  },\n  name: {\n    type: String,\n    required: true,\n    trim: true,\n    maxlength: 50\n  },\n  description: {\n    type: String,\n    trim: true,\n    maxlength: 200\n  },\n  // Scale configuration\n  minValue: {\n    type: Number,\n    default: 1\n  },\n  maxValue: {\n    type: Number,\n    default: 5\n  },\n  // Labels for scale points (optional)\n  scaleLabels: {\n    type: Map,\n    of: String,\n    default: new Map()\n  },\n  // Color for UI display\n  color: {\n    type: String,\n    default: '#3B82F6' // Default blue\n  },\n  // Order for display\n  sortOrder: {\n    type: Number,\n    default: 0\n  },\n  // Active status\n  isActive: {\n    type: Boolean,\n    default: true\n  }\n}, {\n  timestamps: true\n});\n\n// Compound index for user's metrics\nmetricSchema.index({ userId: 1, sortOrder: 1 });\nmetricSchema.index({ userId: 1, isActive: 1 });\n\n// Ensure metric names are unique per user\nmetricSchema.index({ userId: 1, name: 1 }, { unique: true });\n\n// Export the model\nexport default mongoose.models.Metric || mongoose.model<IMetric>('Metric', metricSchema);\n"],"names":[],"mappings":";;;AAAA;;AAiBA,2BAA2B;AAC3B,MAAM,eAAe,IAAI,yGAAA,CAAA,SAAM,CAAU;IACvC,QAAQ;QACN,MAAM,yGAAA,CAAA,SAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,MAAM;QACJ,MAAM;QACN,UAAU;QACV,MAAM;QACN,WAAW;IACb;IACA,aAAa;QACX,MAAM;QACN,MAAM;QACN,WAAW;IACb;IACA,sBAAsB;IACtB,UAAU;QACR,MAAM;QACN,SAAS;IACX;IACA,UAAU;QACR,MAAM;QACN,SAAS;IACX;IACA,qCAAqC;IACrC,aAAa;QACX,MAAM;QACN,IAAI;QACJ,SAAS,IAAI;IACf;IACA,uBAAuB;IACvB,OAAO;QACL,MAAM;QACN,SAAS,UAAU,eAAe;IACpC;IACA,oBAAoB;IACpB,WAAW;QACT,MAAM;QACN,SAAS;IACX;IACA,gBAAgB;IAChB,UAAU;QACR,MAAM;QACN,SAAS;IACX;AACF,GAAG;IACD,YAAY;AACd;AAEA,oCAAoC;AACpC,aAAa,KAAK,CAAC;IAAE,QAAQ;IAAG,WAAW;AAAE;AAC7C,aAAa,KAAK,CAAC;IAAE,QAAQ;IAAG,UAAU;AAAE;AAE5C,0CAA0C;AAC1C,aAAa,KAAK,CAAC;IAAE,QAAQ;IAAG,MAAM;AAAE,GAAG;IAAE,QAAQ;AAAK;uCAG3C,yGAAA,CAAA,UAAQ,CAAC,MAAM,CAAC,MAAM,IAAI,yGAAA,CAAA,UAAQ,CAAC,KAAK,CAAU,UAAU","debugId":null}},
    {"offset": {"line": 266, "column": 0}, "map": {"version":3,"sources":["file:///home/sabid/dev/aura/models/Tag.ts"],"sourcesContent":["import mongoose, { Document, Schema, Types } from 'mongoose';\n\n// TypeScript interface for Tag document\nexport interface ITag extends Document {\n  userId: Types.ObjectId;\n  name: string;\n  description?: string;\n  category: string;\n  color: string;\n  icon?: string;\n  sortOrder: number;\n  usageCount: number;\n  lastUsedAt?: Date;\n  isActive: boolean;\n  keywords: string[];\n  createdAt: Date;\n  updatedAt: Date;\n  incrementUsage(): Promise<ITag>;\n}\n\n// Tag schema definition\nconst tagSchema = new Schema<ITag>({\n  userId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true\n  },\n  name: {\n    type: String,\n    required: true,\n    trim: true,\n    maxlength: 50\n  },\n  description: {\n    type: String,\n    trim: true,\n    maxlength: 200\n  },\n  // Category for grouping tags\n  category: {\n    type: String,\n    trim: true,\n    maxlength: 30,\n    default: 'General'\n  },\n  // Color for UI display\n  color: {\n    type: String,\n    default: '#10B981' // Default green\n  },\n  // Icon or emoji for display\n  icon: {\n    type: String,\n    maxlength: 10\n  },\n  // Order for display\n  sortOrder: {\n    type: Number,\n    default: 0\n  },\n  // Usage statistics\n  usageCount: {\n    type: Number,\n    default: 0\n  },\n  lastUsedAt: {\n    type: Date\n  },\n  // Active status\n  isActive: {\n    type: Boolean,\n    default: true\n  },\n  // AI extraction keywords (for journal parsing)\n  keywords: [{\n    type: String,\n    trim: true,\n    lowercase: true\n  }]\n}, {\n  timestamps: true\n});\n\n// Compound indexes for user's tags\ntagSchema.index({ userId: 1, sortOrder: 1 });\ntagSchema.index({ userId: 1, isActive: 1 });\ntagSchema.index({ userId: 1, category: 1 });\ntagSchema.index({ userId: 1, usageCount: -1 });\n\n// Ensure tag names are unique per user\ntagSchema.index({ userId: 1, name: 1 }, { unique: true });\n\n// Text index for keyword search\ntagSchema.index({ name: 'text', keywords: 'text' });\n\n// Method to increment usage count\ntagSchema.methods.incrementUsage = function(this: ITag): Promise<ITag> {\n  this.usageCount++;\n  this.lastUsedAt = new Date();\n  return this.save();\n};\n\n// Export the model\nexport default mongoose.models.Tag || mongoose.model<ITag>('Tag', tagSchema);\n"],"names":[],"mappings":";;;AAAA;;AAoBA,wBAAwB;AACxB,MAAM,YAAY,IAAI,yGAAA,CAAA,SAAM,CAAO;IACjC,QAAQ;QACN,MAAM,yGAAA,CAAA,SAAM,CAAC,KAAK,CAAC,QAAQ;QAC3B,KAAK;QACL,UAAU;IACZ;IACA,MAAM;QACJ,MAAM;QACN,UAAU;QACV,MAAM;QACN,WAAW;IACb;IACA,aAAa;QACX,MAAM;QACN,MAAM;QACN,WAAW;IACb;IACA,6BAA6B;IAC7B,UAAU;QACR,MAAM;QACN,MAAM;QACN,WAAW;QACX,SAAS;IACX;IACA,uBAAuB;IACvB,OAAO;QACL,MAAM;QACN,SAAS,UAAU,gBAAgB;IACrC;IACA,4BAA4B;IAC5B,MAAM;QACJ,MAAM;QACN,WAAW;IACb;IACA,oBAAoB;IACpB,WAAW;QACT,MAAM;QACN,SAAS;IACX;IACA,mBAAmB;IACnB,YAAY;QACV,MAAM;QACN,SAAS;IACX;IACA,YAAY;QACV,MAAM;IACR;IACA,gBAAgB;IAChB,UAAU;QACR,MAAM;QACN,SAAS;IACX;IACA,+CAA+C;IAC/C,UAAU;QAAC;YACT,MAAM;YACN,MAAM;YACN,WAAW;QACb;KAAE;AACJ,GAAG;IACD,YAAY;AACd;AAEA,mCAAmC;AACnC,UAAU,KAAK,CAAC;IAAE,QAAQ;IAAG,WAAW;AAAE;AAC1C,UAAU,KAAK,CAAC;IAAE,QAAQ;IAAG,UAAU;AAAE;AACzC,UAAU,KAAK,CAAC;IAAE,QAAQ;IAAG,UAAU;AAAE;AACzC,UAAU,KAAK,CAAC;IAAE,QAAQ;IAAG,YAAY,CAAC;AAAE;AAE5C,uCAAuC;AACvC,UAAU,KAAK,CAAC;IAAE,QAAQ;IAAG,MAAM;AAAE,GAAG;IAAE,QAAQ;AAAK;AAEvD,gCAAgC;AAChC,UAAU,KAAK,CAAC;IAAE,MAAM;IAAQ,UAAU;AAAO;AAEjD,kCAAkC;AAClC,UAAU,OAAO,CAAC,cAAc,GAAG;IACjC,IAAI,CAAC,UAAU;IACf,IAAI,CAAC,UAAU,GAAG,IAAI;IACtB,OAAO,IAAI,CAAC,IAAI;AAClB;uCAGe,yGAAA,CAAA,UAAQ,CAAC,MAAM,CAAC,GAAG,IAAI,yGAAA,CAAA,UAAQ,CAAC,KAAK,CAAO,OAAO","debugId":null}},
    {"offset": {"line": 375, "column": 0}, "map": {"version":3,"sources":["file:///home/sabid/dev/aura/models/ActionLog.ts"],"sourcesContent":["import mongoose, { Document, Schema, Types } from 'mongoose';\n\n// Source type for action logging\nexport type ActionSource = 'manual' | 'journal' | 'api';\n\n// TypeScript interface for ActionLog document\nexport interface IActionLog extends Document {\n  userId: Types.ObjectId;\n  tagId: Types.ObjectId;\n  loggedAt: Date;\n  date: string;\n  source: ActionSource;\n  notes?: string;\n  intensity?: number;\n  duration?: number;\n  context?: string;\n  journalEntryId?: Types.ObjectId;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Static methods interface\nexport interface IActionLogModel extends mongoose.Model<IActionLog> {\n  getActionsForDateRange(userId: Types.ObjectId, startDate: string, endDate: string): Promise<IActionLog[]>;\n  getDailyActionCounts(userId: Types.ObjectId, days?: number): Promise<any[]>;\n}\n\n// ActionLog schema definition\nconst actionLogSchema = new Schema<IActionLog>({\n  userId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true\n  },\n  tagId: {\n    type: Schema.Types.ObjectId,\n    ref: 'Tag',\n    required: true\n  },\n  // When the action occurred\n  loggedAt: {\n    type: Date,\n    default: Date.now,\n    required: true\n  },\n  // Date in YYYY-MM-DD format for easy querying\n  date: {\n    type: String,\n    required: true\n  },\n  // How the action was logged\n  source: {\n    type: String,\n    enum: ['manual', 'journal', 'api'],\n    default: 'manual'\n  },\n  // Additional context (optional)\n  notes: {\n    type: String,\n    trim: true,\n    maxlength: 500\n  },\n  // Intensity or rating (optional)\n  intensity: {\n    type: Number,\n    min: 1,\n    max: 5\n  },\n  // Duration in minutes (optional)\n  duration: {\n    type: Number,\n    min: 0\n  },\n  // Location or context (optional)\n  context: {\n    type: String,\n    trim: true,\n    maxlength: 100\n  },\n  // Reference to journal entry if logged via AI\n  journalEntryId: {\n    type: Schema.Types.ObjectId,\n    ref: 'JournalEntry'\n  }\n}, {\n  timestamps: true\n});\n\n// Indexes for efficient querying\nactionLogSchema.index({ userId: 1, date: -1 });\nactionLogSchema.index({ userId: 1, tagId: 1, date: -1 });\nactionLogSchema.index({ userId: 1, loggedAt: -1 });\nactionLogSchema.index({ tagId: 1, date: -1 });\n\n// Compound index for analytics queries\nactionLogSchema.index({ userId: 1, date: 1, tagId: 1 });\n\n// Pre-save middleware to set the date field\nactionLogSchema.pre('save', function(this: IActionLog, next) {\n  if (this.loggedAt) {\n    // Convert loggedAt to YYYY-MM-DD format\n    const date = new Date(this.loggedAt);\n    this.date = date.toISOString().split('T')[0];\n  }\n  next();\n});\n\n// Static method to get actions for a date range\nactionLogSchema.statics.getActionsForDateRange = function(\n  this: IActionLogModel,\n  userId: Types.ObjectId,\n  startDate: string,\n  endDate: string\n): Promise<IActionLog[]> {\n  return this.find({\n    userId,\n    date: {\n      $gte: startDate,\n      $lte: endDate\n    }\n  }).populate('tagId').sort({ loggedAt: -1 });\n};\n\n// Static method to get daily action counts\nactionLogSchema.statics.getDailyActionCounts = function(\n  this: IActionLogModel,\n  userId: Types.ObjectId,\n  days: number = 30\n): Promise<any[]> {\n  const startDate = new Date();\n  startDate.setDate(startDate.getDate() - days);\n  const startDateStr = startDate.toISOString().split('T')[0];\n  \n  return this.aggregate([\n    {\n      $match: {\n        userId: new mongoose.Types.ObjectId(userId.toString()),\n        date: { $gte: startDateStr }\n      }\n    },\n    {\n      $group: {\n        _id: '$date',\n        count: { $sum: 1 },\n        tags: { $addToSet: '$tagId' }\n      }\n    },\n    {\n      $sort: { _id: -1 }\n    }\n  ]);\n};\n\n// Export the model\nexport default mongoose.models.ActionLog || mongoose.model<IActionLog, IActionLogModel>('ActionLog', actionLogSchema);\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 526, "column": 0}, "map": {"version":3,"sources":["file:///home/sabid/dev/aura/models/DailyRating.ts"],"sourcesContent":["import mongoose, { Document, Schema, Types } from 'mongoose';\n\n// Interface for individual rating\nexport interface IRating {\n  metricId: Types.ObjectId;\n  value: number;\n  notes?: string;\n}\n\n// TypeScript interface for DailyRating document\nexport interface IDailyRating extends Document {\n  userId: Types.ObjectId;\n  date: string;\n  ratings: Map<string, IRating>;\n  dayNotes?: string;\n  submittedAt: Date;\n  overallMood?: number;\n  overallEnergy?: number;\n  sleepQuality?: number;\n  sleepHours?: number;\n  createdAt: Date;\n  updatedAt: Date;\n  getRatingForMetric(metricId: Types.ObjectId): IRating | undefined;\n  setRatingForMetric(metricId: Types.ObjectId, value: number, notes?: string): void;\n}\n\n// Static methods interface\nexport interface IDailyRatingModel extends mongoose.Model<IDailyRating> {\n  getRatingsForDateRange(userId: Types.ObjectId, startDate: string, endDate: string): Promise<IDailyRating[]>;\n  getAverageRatings(userId: Types.ObjectId, metricId: Types.ObjectId, days?: number): Promise<any[]>;\n}\n\n// DailyRating schema definition\nconst dailyRatingSchema = new Schema<IDailyRating>({\n  userId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true\n  },\n  // Date in YYYY-MM-DD format\n  date: {\n    type: String,\n    required: true\n  },\n  // Map of metricId to rating value\n  ratings: {\n    type: Map,\n    of: {\n      metricId: {\n        type: Schema.Types.ObjectId,\n        ref: 'Metric',\n        required: true\n      },\n      value: {\n        type: Number,\n        required: true,\n        min: 1,\n        max: 5\n      },\n      notes: {\n        type: String,\n        trim: true,\n        maxlength: 200\n      }\n    },\n    required: true\n  },\n  // Overall notes for the day\n  dayNotes: {\n    type: String,\n    trim: true,\n    maxlength: 1000\n  },\n  // When the rating was submitted\n  submittedAt: {\n    type: Date,\n    default: Date.now\n  },\n  // Mood tracking (optional quick rating)\n  overallMood: {\n    type: Number,\n    min: 1,\n    max: 5\n  },\n  // Energy level (optional quick rating)\n  overallEnergy: {\n    type: Number,\n    min: 1,\n    max: 5\n  },\n  // Sleep quality from previous night\n  sleepQuality: {\n    type: Number,\n    min: 1,\n    max: 5\n  },\n  sleepHours: {\n    type: Number,\n    min: 0,\n    max: 24\n  }\n}, {\n  timestamps: true\n});\n\n// Compound unique index to ensure one rating per user per day\ndailyRatingSchema.index({ userId: 1, date: 1 }, { unique: true });\n\n// Index for date range queries\ndailyRatingSchema.index({ userId: 1, date: -1 });\n\n// Index for analytics queries\ndailyRatingSchema.index({ userId: 1, submittedAt: -1 });\n\n// Static method to get ratings for a date range\ndailyRatingSchema.statics.getRatingsForDateRange = function(\n  this: IDailyRatingModel,\n  userId: Types.ObjectId,\n  startDate: string,\n  endDate: string\n): Promise<IDailyRating[]> {\n  return this.find({\n    userId,\n    date: {\n      $gte: startDate,\n      $lte: endDate\n    }\n  }).sort({ date: -1 });\n};\n\n// Static method to get average ratings for metrics\ndailyRatingSchema.statics.getAverageRatings = function(\n  this: IDailyRatingModel,\n  userId: Types.ObjectId,\n  metricId: Types.ObjectId,\n  days: number = 30\n): Promise<any[]> {\n  const startDate = new Date();\n  startDate.setDate(startDate.getDate() - days);\n  const startDateStr = startDate.toISOString().split('T')[0];\n  \n  return this.aggregate([\n    {\n      $match: {\n        userId: new mongoose.Types.ObjectId(userId.toString()),\n        date: { $gte: startDateStr }\n      }\n    },\n    {\n      $addFields: {\n        ratingsArray: { $objectToArray: '$ratings' }\n      }\n    },\n    {\n      $unwind: '$ratingsArray'\n    },\n    {\n      $match: {\n        'ratingsArray.v.metricId': new mongoose.Types.ObjectId(metricId.toString())\n      }\n    },\n    {\n      $group: {\n        _id: '$userId',\n        averageRating: { $avg: '$ratingsArray.v.value' },\n        count: { $sum: 1 },\n        minRating: { $min: '$ratingsArray.v.value' },\n        maxRating: { $max: '$ratingsArray.v.value' }\n      }\n    }\n  ]);\n};\n\n// Instance method to get rating for a specific metric\ndailyRatingSchema.methods.getRatingForMetric = function(\n  this: IDailyRating,\n  metricId: Types.ObjectId\n): IRating | undefined {\n  const metricIdStr = metricId.toString();\n  return this.ratings.get(metricIdStr);\n};\n\n// Instance method to set rating for a specific metric\ndailyRatingSchema.methods.setRatingForMetric = function(\n  this: IDailyRating,\n  metricId: Types.ObjectId,\n  value: number,\n  notes: string = ''\n): void {\n  const metricIdStr = metricId.toString();\n  this.ratings.set(metricIdStr, {\n    metricId: metricId,\n    value: value,\n    notes: notes\n  });\n};\n\n// Export the model\nexport default mongoose.models.DailyRating || mongoose.model<IDailyRating, IDailyRatingModel>('DailyRating', dailyRatingSchema);\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 699, "column": 0}, "map": {"version":3,"sources":["file:///home/sabid/dev/aura/models/Insight.ts"],"sourcesContent":["import mongoose, { Schema, Types } from 'mongoose';\n\n// Type definitions\nexport type CorrelationType = 'positive' | 'negative' | 'neutral';\nexport type InsightStatus = 'active' | 'dismissed' | 'archived';\nexport type InsightCategory = 'health' | 'productivity' | 'mood' | 'energy' | 'sleep' | 'exercise' | 'nutrition' | 'social' | 'other';\n\n// Interface for statistical data\nexport interface IStatisticalData {\n  avgWithTag: number;\n  avgWithoutTag: number;\n  daysWithTag: number;\n  daysWithoutTag: number;\n  analysisStartDate: string;\n  analysisEndDate: string;\n}\n\n// TypeScript interface for Insight document\nexport interface IInsight {\n  userId: Types.ObjectId;\n  tagId: Types.ObjectId;\n  metricId: Types.ObjectId;\n  correlationType: CorrelationType;\n  correlationStrength: number;\n  pValue?: number;\n  content: string;\n  title: string;\n  statisticalData: IStatisticalData;\n  status: InsightStatus;\n  isRead: boolean;\n  readAt?: Date;\n  userRating?: number;\n  userFeedback?: string;\n  priority: number;\n  categories: InsightCategory[];\n  createdAt: Date;\n  updatedAt: Date;\n  correlationDescription: string; // virtual field\n  markAsRead(): Promise<IInsight>;\n  dismiss(): Promise<IInsight>;\n  getImpactDescription(): string;\n  [key: string]: any; // Allow virtuals\n}\n\n// Static methods interface\nexport interface IInsightModel extends mongoose.Model<IInsight> {\n  getInsightsForUser(userId: Types.ObjectId, status?: InsightStatus): Promise<IInsight[]>;\n  getUnreadCount(userId: Types.ObjectId): Promise<number>;\n}\n\n// StatisticalData sub-schema\nconst statisticalDataSchema = new Schema({\n  avgWithTag: { type: Number, required: true },\n  avgWithoutTag: { type: Number, required: true },\n  daysWithTag: { type: Number, required: true },\n  daysWithoutTag: { type: Number, required: true },\n  analysisStartDate: { type: String, required: true },\n  analysisEndDate: { type: String, required: true }\n}, { _id: false });\n\n// Insight schema definition\nconst insightSchema = new Schema({\n  userId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true\n  },\n  // The tag that was analyzed\n  tagId: {\n    type: Schema.Types.ObjectId,\n    ref: 'Tag',\n    required: true\n  },\n  // The metric that was correlated\n  metricId: {\n    type: Schema.Types.ObjectId,\n    ref: 'Metric',\n    required: true\n  },\n  // Type of correlation found\n  correlationType: {\n    type: String,\n    enum: ['positive', 'negative', 'neutral'],\n    required: true\n  },\n  // Strength of correlation (0-1)\n  correlationStrength: {\n    type: Number,\n    min: 0,\n    max: 1,\n    required: true\n  },\n  // Statistical significance (p-value)\n  pValue: {\n    type: Number,\n    min: 0,\n    max: 1\n  },\n  // AI-generated insight content\n  content: {\n    type: String,\n    required: true,\n    maxlength: 1000\n  },\n  // Short title for the insight\n  title: {\n    type: String,\n    required: true,\n    maxlength: 100\n  },\n  // Statistical data supporting the insight\n  statisticalData: { type: statisticalDataSchema, required: true },\n  // Insight status\n  status: {\n    type: String,\n    enum: ['active', 'dismissed', 'archived'],\n    default: 'active'\n  },\n  // User interaction\n  isRead: {\n    type: Boolean,\n    default: false\n  },\n  readAt: {\n    type: Date\n  },\n  userRating: {\n    type: Number,\n    min: 1,\n    max: 5\n  },\n  userFeedback: {\n    type: String,\n    maxlength: 500\n  },\n  // Priority for display (higher = more important)\n  priority: {\n    type: Number,\n    default: 0\n  },\n  // Tags for categorization\n  categories: [{\n    type: String,\n    enum: ['health', 'productivity', 'mood', 'energy', 'sleep', 'exercise', 'nutrition', 'social', 'other']\n  }]\n}, {\n  timestamps: true\n});\n\n// Indexes for efficient querying\ninsightSchema.index({ userId: 1, createdAt: -1 });\ninsightSchema.index({ userId: 1, status: 1, priority: -1 });\ninsightSchema.index({ userId: 1, tagId: 1, metricId: 1 });\ninsightSchema.index({ userId: 1, isRead: 1 });\n\n// Compound index to prevent duplicate insights\ninsightSchema.index({ userId: 1, tagId: 1, metricId: 1, correlationType: 1 }, { unique: true });\n\n// Static method to get insights for user\ninsightSchema.statics.getInsightsForUser = function(\n  this: IInsightModel,\n  userId: Types.ObjectId,\n  status: InsightStatus = 'active'\n): Promise<IInsight[]> {\n  return this.find({ userId, status })\n    .populate('tagId', 'name color icon')\n    .populate('metricId', 'name color')\n    .sort({ priority: -1, createdAt: -1 });\n};\n\n// Static method to get unread insights count\ninsightSchema.statics.getUnreadCount = function(\n  this: IInsightModel,\n  userId: Types.ObjectId\n): Promise<number> {\n  return this.countDocuments({ userId, isRead: false, status: 'active' });\n};\n\n// Instance method to mark as read\ninsightSchema.methods.markAsRead = function(this: IInsight): Promise<IInsight> {\n  this.isRead = true;\n  this.readAt = new Date();\n  return this.save();\n};\n\n// Instance method to dismiss insight\ninsightSchema.methods.dismiss = function(this: IInsight): Promise<IInsight> {\n  this.status = 'dismissed';\n  return this.save();\n};\n\n// Instance method to get impact description\ninsightSchema.methods.getImpactDescription = function(this: IInsight): string {\n  const diff = Math.abs(this.statisticalData.avgWithTag - this.statisticalData.avgWithoutTag);\n  const percentage = ((diff / this.statisticalData.avgWithoutTag) * 100).toFixed(1);\n  \n  if (this.correlationType === 'positive') {\n    return `${percentage}% higher on average`;\n  } else if (this.correlationType === 'negative') {\n    return `${percentage}% lower on average`;\n  }\n  return 'No significant difference';\n};\n\n// Virtual for correlation description\ninsightSchema.virtual('correlationDescription').get(function(this: IInsight) {\n  const strength = this.correlationStrength;\n  if (strength >= 0.7) return 'Strong';\n  if (strength >= 0.5) return 'Moderate';\n  if (strength >= 0.3) return 'Weak';\n  return 'Very Weak';\n});\n\n// Ensure virtual fields are included in JSON\ninsightSchema.set('toJSON', { virtuals: true });\n\n// Export the model\nexport default (mongoose.models.Insight as unknown as IInsightModel) || (mongoose.model('Insight', insightSchema) as unknown as IInsightModel);\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 929, "column": 0}, "map": {"version":3,"sources":["file:///home/sabid/dev/aura/models/JournalEntry.ts"],"sourcesContent":["import mongoose, { Document, Schema, Types } from 'mongoose';\n\n// Type definitions\nexport type ProcessingStatus = 'pending' | 'processing' | 'completed' | 'failed';\nexport type SentimentLabel = 'very_negative' | 'negative' | 'neutral' | 'positive' | 'very_positive';\nexport type EntryCategory = 'daily' | 'reflection' | 'goals' | 'gratitude' | 'challenges' | 'insights' | 'other';\n\n// Interface for sentiment analysis\nexport interface ISentiment {\n  score: number;\n  label: SentimentLabel;\n  confidence: number;\n}\n\n// Interface for extracted tags\nexport interface IExtractedTag {\n  tagId: Types.ObjectId;\n  confidence: number;\n  extractedText: string;\n}\n\n// Interface for AI response metadata\nexport interface IAIResponse {\n  model: string;\n  processingTime: number;\n  tokensUsed: number;\n  rawResponse: string;\n}\n\n// Interface for processing error\nexport interface IProcessingError {\n  message: string;\n  code: string;\n  timestamp: Date;\n}\n\n// TypeScript interface for JournalEntry document\nexport interface IJournalEntry extends Document {\n  userId: Types.ObjectId;\n  content: string;\n  date: string;\n  entryDate: Date;\n  sentiment?: ISentiment;\n  aiProcessingStatus: ProcessingStatus;\n  extractedTags: IExtractedTag[];\n  aiResponse?: IAIResponse;\n  processingError?: IProcessingError;\n  categories: EntryCategory[];\n  isPrivate: boolean;\n  wordCount: number;\n  createdAt: Date;\n  updatedAt: Date;\n  processingStatusDisplay: string; // virtual field\n  markAsProcessing(): Promise<IJournalEntry>;\n  markProcessingCompleted(extractedTags: IExtractedTag[], aiResponse: IAIResponse): Promise<IJournalEntry>;\n  markProcessingFailed(error: Error): Promise<IJournalEntry>;\n  getSummary(maxLength?: number): string;\n}\n\n// Static methods interface\nexport interface IJournalEntryModel extends mongoose.Model<IJournalEntry> {\n  getEntriesForDateRange(userId: Types.ObjectId, startDate: string, endDate: string): Promise<IJournalEntry[]>;\n  getPendingProcessing(): Promise<IJournalEntry[]>;\n}\n\n// JournalEntry schema definition\nconst journalEntrySchema = new Schema<IJournalEntry>({\n  userId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n    required: true\n  },\n  // Original journal text\n  content: {\n    type: String,\n    required: true,\n    maxlength: 5000\n  },\n  // Date of the entry\n  date: {\n    type: String,\n    required: true\n  },\n  // Entry metadata\n  entryDate: {\n    type: Date,\n    default: Date.now\n  },\n  // Mood/sentiment analysis (optional)\n  sentiment: {\n    score: {\n      type: Number,\n      min: -1,\n      max: 1\n    },\n    label: {\n      type: String,\n      enum: ['very_negative', 'negative', 'neutral', 'positive', 'very_positive']\n    },\n    confidence: {\n      type: Number,\n      min: 0,\n      max: 1\n    }\n  },\n  // AI processing status\n  aiProcessingStatus: {\n    type: String,\n    enum: ['pending', 'processing', 'completed', 'failed'],\n    default: 'pending'\n  },\n  // AI extracted tags\n  extractedTags: [{\n    tagId: {\n      type: Schema.Types.ObjectId,\n      ref: 'Tag'\n    },\n    confidence: {\n      type: Number,\n      min: 0,\n      max: 1\n    },\n    extractedText: {\n      type: String\n    }\n  }],\n  // AI response metadata\n  aiResponse: {\n    model: String,\n    processingTime: Number, // in milliseconds\n    tokensUsed: Number,\n    rawResponse: String\n  },\n  // Error information if AI processing failed\n  processingError: {\n    message: String,\n    code: String,\n    timestamp: Date\n  },\n  // Entry tags/categories\n  categories: [{\n    type: String,\n    enum: ['daily', 'reflection', 'goals', 'gratitude', 'challenges', 'insights', 'other']\n  }],\n  // Privacy settings\n  isPrivate: {\n    type: Boolean,\n    default: true\n  },\n  // Word count for analytics\n  wordCount: {\n    type: Number,\n    default: 0\n  }\n}, {\n  timestamps: true\n});\n\n// Indexes for efficient querying\njournalEntrySchema.index({ userId: 1, date: -1 });\njournalEntrySchema.index({ userId: 1, entryDate: -1 });\njournalEntrySchema.index({ userId: 1, aiProcessingStatus: 1 });\n\n// Text index for searching journal content\njournalEntrySchema.index({ content: 'text' });\n\n// Pre-save middleware to calculate word count and set date\njournalEntrySchema.pre('save', function(this: IJournalEntry, next) {\n  // Calculate word count\n  this.wordCount = this.content.trim().split(/\\s+/).length;\n  \n  // Set date if not provided\n  if (!this.date) {\n    this.date = new Date().toISOString().split('T')[0];\n  }\n  \n  next();\n});\n\n// Static method to get entries for date range\njournalEntrySchema.statics.getEntriesForDateRange = function(\n  this: IJournalEntryModel,\n  userId: Types.ObjectId,\n  startDate: string,\n  endDate: string\n): Promise<IJournalEntry[]> {\n  return this.find({\n    userId,\n    date: {\n      $gte: startDate,\n      $lte: endDate\n    }\n  }).sort({ date: -1 });\n};\n\n// Static method to get entries pending AI processing\njournalEntrySchema.statics.getPendingProcessing = function(\n  this: IJournalEntryModel\n): Promise<IJournalEntry[]> {\n  return this.find({\n    aiProcessingStatus: { $in: ['pending', 'processing'] }\n  }).sort({ entryDate: 1 });\n};\n\n// Instance method to mark as processing\njournalEntrySchema.methods.markAsProcessing = function(this: IJournalEntry): Promise<IJournalEntry> {\n  this.aiProcessingStatus = 'processing';\n  return this.save();\n};\n\n// Instance method to mark processing as completed\njournalEntrySchema.methods.markProcessingCompleted = function(\n  this: IJournalEntry,\n  extractedTags: IExtractedTag[],\n  aiResponse: IAIResponse\n): Promise<IJournalEntry> {\n  this.aiProcessingStatus = 'completed';\n  this.extractedTags = extractedTags;\n  this.aiResponse = aiResponse;\n  return this.save();\n};\n\n// Instance method to mark processing as failed\njournalEntrySchema.methods.markProcessingFailed = function(\n  this: IJournalEntry,\n  error: Error\n): Promise<IJournalEntry> {\n  this.aiProcessingStatus = 'failed';\n  this.processingError = {\n    message: error.message,\n    code: (error as any).code || 'UNKNOWN_ERROR',\n    timestamp: new Date()\n  };\n  return this.save();\n};\n\n// Instance method to get summary\njournalEntrySchema.methods.getSummary = function(\n  this: IJournalEntry,\n  maxLength: number = 100\n): string {\n  if (this.content.length <= maxLength) {\n    return this.content;\n  }\n  return this.content.substring(0, maxLength).trim() + '...';\n};\n\n// Virtual for getting readable processing status\njournalEntrySchema.virtual('processingStatusDisplay').get(function(this: IJournalEntry) {\n  const statusMap = {\n    'pending': 'Waiting for processing',\n    'processing': 'Analyzing entry...',\n    'completed': 'Analysis complete',\n    'failed': 'Processing failed'\n  };\n  return statusMap[this.aiProcessingStatus] || 'Unknown status';\n});\n\n// Ensure virtual fields are included in JSON\njournalEntrySchema.set('toJSON', { virtuals: true });\n\n// Export the model\nexport default mongoose.models.JournalEntry || mongoose.model<IJournalEntry, IJournalEntryModel>('JournalEntry', journalEntrySchema);\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1149, "column": 0}, "map": {"version":3,"sources":["file:///home/sabid/dev/aura/models/index.ts"],"sourcesContent":["// Export all models and their types\nexport { default as User, type IUser } from './User';\nexport { default as Metric, type IMetric } from './Metric';\nexport { default as Tag, type ITag } from './Tag';\nexport { default as ActionLog, type IActionLog, type IActionLogModel, type ActionSource } from './ActionLog';\nexport { default as DailyRating, type IDailyRating, type IDailyRatingModel, type IRating } from './DailyRating';\nexport { default as Insight, type IInsight, type IInsightModel, type CorrelationType, type InsightStatus, type InsightCategory, type IStatisticalData } from './Insight';\nexport { default as JournalEntry, type IJournalEntry, type IJournalEntryModel, type ProcessingStatus, type SentimentLabel, type EntryCategory, type ISentiment, type IExtractedTag, type IAIResponse, type IProcessingError } from './JournalEntry';\n"],"names":[],"mappings":"AAAA,oCAAoC;;AACpC;AACA;AACA;AACA;AACA;AACA;AACA","debugId":null}},
    {"offset": {"line": 1203, "column": 0}, "map": {"version":3,"sources":["file:///home/sabid/dev/aura/app/api/auth/signup/route.ts"],"sourcesContent":["\nimport { NextResponse } from 'next/server';\nimport bcrypt from 'bcryptjs';\nimport { connect } from '@/models/index';\nimport User from '@/models/User';\n\nexport async function POST(req: Request) {\n  await connect();\n\n  try {\n    const { username, email, password } = await req.json();\n\n    // Basic validation\n    if (!username || !email || !password) {\n      return NextResponse.json({ message: 'All fields are required' }, { status: 400 });\n    }\n\n    if (password.length < 8) {\n        return NextResponse.json({ message: 'Password must be at least 8 characters long' }, { status: 400 });\n    }\n\n    // Check if user already exists\n    const existingUser = await User.findOne({ $or: [{ email }, { username }] });\n    if (existingUser) {\n      return NextResponse.json({ message: 'User with that email or username already exists' }, { status: 409 });\n    }\n\n    // Hash password\n    const hashedPassword = await bcrypt.hash(password, 10);\n\n    // Create new user\n    const newUser = new User({\n      username,\n      email,\n      password: hashedPassword,\n    });\n\n    await newUser.save();\n\n    // In a real app, you'd also handle session creation/login here\n\n    return NextResponse.json({ message: 'User created successfully' }, { status: 201 });\n\n  } catch (error) {\n    console.error(error);\n    return NextResponse.json({ message: 'Internal Server Error' }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;AACA;AACA;AACA;AAAA;AACA;;;;;AAEO,eAAe,KAAK,GAAY;IACrC,MAAM,CAAA,GAAA,kIAAA,CAAA,UAAO,AAAD;IAEZ,IAAI;QACF,MAAM,EAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAI,IAAI;QAEpD,mBAAmB;QACnB,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,UAAU;YACpC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAA0B,GAAG;gBAAE,QAAQ;YAAI;QACjF;QAEA,IAAI,SAAS,MAAM,GAAG,GAAG;YACrB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAA8C,GAAG;gBAAE,QAAQ;YAAI;QACvG;QAEA,+BAA+B;QAC/B,MAAM,eAAe,MAAM,gHAAA,CAAA,UAAI,CAAC,OAAO,CAAC;YAAE,KAAK;gBAAC;oBAAE;gBAAM;gBAAG;oBAAE;gBAAS;aAAE;QAAC;QACzE,IAAI,cAAc;YAChB,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;gBAAE,SAAS;YAAkD,GAAG;gBAAE,QAAQ;YAAI;QACzG;QAEA,gBAAgB;QAChB,MAAM,iBAAiB,MAAM,mIAAA,CAAA,UAAM,CAAC,IAAI,CAAC,UAAU;QAEnD,kBAAkB;QAClB,MAAM,UAAU,IAAI,gHAAA,CAAA,UAAI,CAAC;YACvB;YACA;YACA,UAAU;QACZ;QAEA,MAAM,QAAQ,IAAI;QAElB,+DAA+D;QAE/D,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAA4B,GAAG;YAAE,QAAQ;QAAI;IAEnF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC;QACd,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACF","debugId":null}}]
}